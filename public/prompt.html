<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Book Recommendations</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Playfair+Display+SC:wght@700&display=swap" rel="stylesheet">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configure Tailwind to use both Inter and Playfair Display SC fonts
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        serif: ['"Playfair Display SC"', 'serif'],
                    },
                    animation: {
                        'spin': 'spin 1s linear infinite',
                    }
                }
            }
        }
    </script>
    <style>
        .search-input {
            resize: none;
        }
        .search-input::-webkit-scrollbar {
            width: 4px;
        }
        .search-input::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .search-input::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 2px;
        }

        /* --- CSS for Typing Animation --- */
        @keyframes typing {
          from { width: 0; }
          to { width: 100%; }
        }

        @keyframes blink {
          50% { border-color: transparent; }
        }

        .typing-animation {
          display: inline-block; /* Makes the element's width fit its content */
          overflow: hidden; /* Hides the text until the animation reveals it */
          white-space: nowrap; /* Keeps the text on a single line */
          border-right: 4px solid white; /* Creates the white blinking caret */
          animation:
            typing 3.5s steps(59, end) forwards, /* The typing effect, 'forwards' keeps it at 100% width */
            blink .75s step-end infinite; /* The blinking caret effect */
        }
    </style>
</head>
<body class="font-sans bg-black min-h-screen p-5 flex flex-col items-center justify-center">
    <div class="max-w-4xl mx-auto">
        <div class="text-center text-white mb-10">
            <p class="typing-animation font-sans text-[25.7px] mb-4">
                “A Book’s True Worth is Hidden in its Wisdom, <strong class="font-bold">NOT</strong> its Cover”
            </p>
            <h2 class="font-serif text-[42.6px] font-bold uppercase tracking-widest">
                Begin by Asking...
            </h2>
        </div>

        <div class="mb-8">
            <div class="flex items-center w-full bg-white border border-neutral-300 rounded-2xl p-2 transition-all duration-300 focus-within:border-black min-h-[60px]">
                <textarea 
                    class="search-input w-full flex-grow bg-transparent text-black placeholder-neutral-500 pl-4 text-base leading-relaxed focus:outline-none max-h-[250px] overflow-y-auto" 
                    id="promptInput" 
                    placeholder="Ask me anything about books you'd like to read..." 
                    rows="1">
                </textarea>
                <button 
                    class="send-btn flex-shrink-0 w-10 h-10 bg-black text-white rounded-full flex items-center justify-center transition-all duration-300 hover:bg-neutral-800 disabled:bg-neutral-200 disabled:text-neutral-500 disabled:cursor-not-allowed mx-1" 
                    id="sendBtn" disabled>
                    <svg viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="loading hidden text-center text-white text-lg my-5" id="loading">
            <div class="border-4 border-white border-opacity-30 border-t-white rounded-full w-8 h-8 animate-spin mx-auto mb-2.5"></div>
            <p>AI is analyzing your request and finding the best book recommendations...</p>
        </div>

        <div class="results-container hidden" id="resultsContainer">
            </div>
    </div>

    <script>
        /**
         * Manages the entire book recommendation application.
         */
        class BookRecommendationSystem {
            constructor() {
                this.elements = {
                    promptInput: document.getElementById('promptInput'),
                    sendBtn: document.getElementById('sendBtn'),
                    loading: document.getElementById('loading'),
                    resultsContainer: document.getElementById('resultsContainer'),
                };
                this.debugMode = true;
                this.AVAILABLE_GENRES = [
                    "Habits", "Finance", "Leadership", "Mental health", "Motivational", 
                    "Physical Health", "Time Management", "Communication", "Self-Discovery", 
                    "Decision making", "Creativity", "Cognitive intelligence", "Behaviour", 
                    "Emotional Intelligence", "Innovation", "Philosophy", "Entrepreneurship"
                ];
                this.API_BASE_URL = window.location.origin;
                this.initializeEventListeners();
                this.checkServerHealth();
            }

            initializeEventListeners() {
                this.elements.sendBtn.addEventListener('click', () => this.handleSearch());
                this.elements.promptInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleSearch();
                    }
                });
                this.elements.promptInput.addEventListener('input', () => {
                    const input = this.elements.promptInput;
                    input.style.height = 'auto';
                    input.style.height = `${Math.min(input.scrollHeight, 250)}px`;
                    this.elements.sendBtn.disabled = input.value.trim() === '';
                });
            }

            async handleSearch() {
                const prompt = this.elements.promptInput.value.trim();
                if (!prompt) {
                    this.showError('Please enter a prompt to get recommendations.');
                    return;
                }

                this.showLoading(true);
                this.clearResults();

                try {
                    // Step 1: Detect the language of the user's prompt
                    this.showDebugInfo(`Step 1: Detecting prompt language...`);
                    const langDetectionPrompt = this.generateAIPrompt('languageDetection', prompt);
                    const langResult = await this._callBackendAPI('/ai/analyze', { prompt: langDetectionPrompt });
                    const detectedLang = langResult.language || 'en';
                    this.log('Detected language:', detectedLang);
                    this.showDebugInfo(`Detected language: ${detectedLang === 'id' ? 'Indonesian' : 'English'}`);

                    // Step 2: Analyze prompt for genres
                    this.showDebugInfo(`Step 2: Analyzing prompt for genres...`);
                    const genrePrompt = this.generateAIPrompt('genreAnalysis', prompt, this.AVAILABLE_GENRES.join(', '));
                    const genreResult = await this._callBackendAPI('/ai/analyze', { prompt: genrePrompt });
                    const genres = genreResult.genres || [];
                    this.log('Determined genres:', genres);
                    this.showDebugInfo(`Found genres: ${genres.join(', ')}`);
                    if (genres.length === 0) throw new Error('No relevant genres found for your query.');

                    // Step 3: Fetch books from the database
                    this.showDebugInfo(`Step 3: Fetching books from database...`);
                    const books = await this._callBackendAPI('/books/search', { genres });
                    this.log('Found books:', books.length);
                    this.showDebugInfo(`Found ${books.length} books in database`);
                    if (books.length === 0) throw new Error('No books found for the determined genres.');

                    // Step 4: Extract and analyze individual highlights
                    this.showDebugInfo(`Step 4: Extracting and analyzing individual highlights...`);
                    const allHighlights = this._extractAllHighlights(books);
                    this.log('Total extracted highlights:', allHighlights.length);
                    this.showDebugInfo(`Extracted ${allHighlights.length} individual highlights`);
                    if (allHighlights.length === 0) throw new Error('No valid highlights found in the books.');

                    // Step 5: AI analyzing each highlight for relevance
                    this.showDebugInfo(`Step 5: AI analyzing each highlight for relevance...`);
                    const highlightData = allHighlights.map(h => `ID: ${h.id} | Book: "${h.bookTitle}" | Highlight: "${h.text}"`).join('\n');
                    const rankingPrompt = this.generateAIPrompt('highlightRanking', prompt, null, highlightData, allHighlights.length);
                    const rankingResult = await this._callBackendAPI('/ai/analyze', { prompt: rankingPrompt });
                    const selectedHighlightIds = (rankingResult.recommendations || []).map(rec => rec.id);
                    this.log('AI selected highlight IDs:', selectedHighlightIds);

                    let recommendations = this._buildRecommendations(selectedHighlightIds, allHighlights);
                    this.log('Final recommendations count:', recommendations.length);
                    if (recommendations.length === 0) throw new Error('No highlights match your query well enough.');

                    // Step 6: (NEW) Translate highlights if the prompt was in Indonesian
                    if (detectedLang === 'id' && recommendations.length > 0) {
                        this.showDebugInfo(`Step 6: Translating highlights to Indonesian...`);
                        recommendations = await this._translateHighlights(recommendations);
                        this.log('Translated recommendations:', recommendations);
                    }
                    
                    this.showDebugInfo(`Displaying ${recommendations.length} most relevant highlights`);
                    this.displayRecommendations(recommendations);

                } catch (error) {
                    this.log('Error in handleSearch:', error);
                    this.showError(error.message || 'An error occurred while getting recommendations.');
                } finally {
                    this.showLoading(false);
                }
            }
            
            async _translateHighlights(recommendations) {
                const highlightsToTranslate = recommendations.map(rec => rec.highlight);
                const translationPrompt = this.generateAIPrompt('highlightTranslation', null, null, highlightsToTranslate);
                const translationResult = await this._callBackendAPI('/ai/analyze', { prompt: translationPrompt });

                if (!translationResult.translations || translationResult.translations.length !== recommendations.length) {
                    this.log('Translation failed or returned mismatched count.');
                    return recommendations; // Fallback to English if translation fails
                }

                return recommendations.map((rec, index) => {
                    const translatedText = translationResult.translations[index];
                    return {
                        ...rec,
                        highlight: translatedText || rec.highlight // Use translated text or fallback to original
                    };
                });
            }

            displayRecommendations(recommendations) {
                if (!recommendations || recommendations.length === 0) {
                    this.showError('No relevant highlights found that match your query.');
                    return;
                }
                const recommendationsHTML = recommendations
                    .map((rec, index) => this._createRecommendationHTML(rec, index))
                    .join('');
                this.elements.resultsContainer.innerHTML = recommendationsHTML;
                this.elements.resultsContainer.style.display = 'block';
                setTimeout(() => {
                    document.querySelectorAll('.debug-info').forEach(info => info.remove());
                }, 500);
            }

            _createRecommendationHTML(rec, index) {
                const { title, author, highlight } = rec;
                return `
                    <div class="bg-white rounded-2xl p-6 mb-5 shadow-lg border-l-4 border-black transition-transform duration-300 hover:-translate-y-1 hover:shadow-xl relative">
                        <div class="absolute top-4 right-4 bg-black text-white text-xs px-2 py-1 rounded-full font-semibold">
                            #${index + 1} Best Match
                        </div>
                        <div class="text-base leading-relaxed text-neutral-800 bg-neutral-100 p-4 rounded-lg border-l-4 border-neutral-400 italic mb-4 pr-20">"${this.escapeHtml(highlight)}"</div>
                        <div class="text-xl font-bold text-black mb-2">${this.escapeHtml(title)}</div>
                        <div class="text-base text-neutral-600 italic">by ${this.escapeHtml(author)}</div>
                    </div>
                `;
            }

            showLoading(show) {
                this.elements.loading.style.display = show ? 'block' : 'none';
                this.elements.sendBtn.disabled = show;
            }

            clearResults() {
                this.elements.resultsContainer.style.display = 'none';
                this.elements.resultsContainer.innerHTML = '';
                document.querySelectorAll('.error-message, .debug-info').forEach(el => el.remove());
            }

            showError(message) {
                this.clearResults();
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message bg-neutral-800 border border-neutral-600 text-white p-4 rounded-lg my-5 text-center';
                errorDiv.textContent = message;
                this.elements.resultsContainer.parentNode.insertBefore(errorDiv, this.elements.resultsContainer);
                this.log('Error displayed:', message);
            }

            _extractAllHighlights(books) {
                const allHighlights = [];
                books.forEach((book, bookIndex) => {
                    const highlights = this._parseHighlights(book.highlights);
                    highlights.forEach((highlight, highlightIndex) => {
                        allHighlights.push({
                            id: `highlight_${bookIndex}_${highlightIndex}`,
                            text: highlight,
                            bookTitle: book.title,
                            bookAuthor: book.author
                        });
                    });
                });
                return allHighlights;
            }
            
            _buildRecommendations(selectedIds, allHighlights) {
                const recommendations = [];
                for (const id of selectedIds) {
                    const highlight = allHighlights.find(h => h.id === id);
                    if (highlight) {
                        recommendations.push({
                            title: highlight.bookTitle,
                            author: highlight.bookAuthor,
                            highlight: highlight.text
                        });
                    }
                }
                return recommendations;
            }

            async _callBackendAPI(endpoint, data, method = 'POST') {
                try {
                    this.log(`Calling backend API: ${endpoint}`, { data, method });
                    const config = {
                        method: method,
                        headers: { 'Content-Type': 'application/json' },
                    };
                    if (method !== 'GET') {
                        config.body = JSON.stringify(data);
                    }
                    const response = await fetch(`${this.API_BASE_URL}/api${endpoint}`, config);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `API error (${response.status})`);
                    }
                    return await response.json();
                } catch (error) {
                    this.log('Backend API call failed:', error);
                    throw new Error(`Backend API call failed: ${error.message}`);
                }
            }
            
            async checkServerHealth() {
                try {
                    const health = await this._callBackendAPI('/health', null, 'GET');
                    this.log('Server health check:', health);
                    if (!health.env.hasGroqKey || !health.env.hasSupabaseUrl || !health.env.hasSupabaseKey) {
                        this.showError('Server configuration incomplete.');
                    }
                } catch (error) {
                    this.showError('Cannot connect to backend server.');
                }
            }
            
            _parseHighlights(highlightsText) {
                if (!highlightsText || typeof highlightsText !== 'string') return [];
                const regex = /(["“])(.*?)(["”])/g;
                const matches = [...highlightsText.matchAll(regex)];
                if (matches.length > 0) {
                    return matches.map(match => match[2].trim());
                }
                const singleHighlight = highlightsText.trim();
                return singleHighlight ? [singleHighlight] : [];
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            log(message, data = null) {
                if (this.debugMode) console.log(`[DEBUG] ${message}`, data || '');
            }

            showDebugInfo(message) {
                if (!this.debugMode) return;
                const debugDiv = document.createElement('div');
                debugDiv.className = 'debug-info bg-white bg-opacity-10 border border-white border-opacity-30 text-white p-2.5 rounded-lg my-2.5 text-xs font-mono';
                debugDiv.textContent = message;
                this.elements.resultsContainer.parentNode.insertBefore(debugDiv, this.elements.resultsContainer);
            }

            generateAIPrompt(taskType, userPrompt, availableGenres = null, highlightData = null, totalCount = 0) {
                const prompts = {
                    languageDetection: {
                        role: "You are a highly accurate language identification AI.",
                        task: "Analyze the user's query and determine if it is primarily written in English or Indonesian.",
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "language".
- The value must be either "en" for English or "id" for Indonesian.
- Example for Indonesian: {"language": "id"}
- Example for English: {"language": "en"}
- Do NOT include any other text or explanations.`,
                        content: `User query: "${userPrompt}"`
                    },
                    highlightTranslation: {
                        role: "You are an expert translator specializing in conveying the nuanced meaning of book highlights from English to Indonesian.",
                        task: "Translate EACH of the following English book highlights into Indonesian. Preserve the core wisdom, context, and tone of the original highlight. Return the translations in the exact same order as the input.",
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "translations".
- The value must be an array of strings.
- Each string in the array must be the Indonesian translation of the corresponding highlight.
- The order of the translated strings must match the order of the original highlights.
- Example: {"translations": ["Terjemahan pertama.", "Terjemahan kedua."]}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `Original English highlights (JSON array format):\n${JSON.stringify(highlightData)}`
                    },
                    genreAnalysis: {
                        role: "You are a specialized AI assistant with expert knowledge of book genres and user intent analysis. You are fluent in both English and Indonesian.",
                        context: `Available genres: ${availableGenres}`,
                        task: `Analyze the user's query, which can be in English or Indonesian, and determine which book genres would be most relevant.`,
                        process: `
1. First, detect the language of the user's query (English or Indonesian).
2. Carefully read the query to understand the user's needs, interests, or preferences, regardless of the language.
3. Scan the available genres for the best matches based on the query's meaning.
4. Prioritize genres where the benefits directly address the user's query.
5. Select a minimum of 1 and a maximum of 3 genres that are most relevant.
6. If the query is vague, choose the most general applicable genres.`,
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "genres".
- The value of "genres" must be an array of strings.
- Each string must be the exact "Name" of a recommended genre from the provided list.
- Example: {"genres": ["Mental health", "Habits", "Leadership"]}
- If no matches: {"genres": []}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `User query: "${userPrompt}"\n\nSelected genres:`
                    },
                    highlightRanking: {
                        role: "You are an expert content analyst specializing in matching book insights to user queries with surgical precision. You are fluent in both English and Indonesian.",
                        context: `You have ${totalCount} individual book highlights. Your task is to find the most relevant highlights that directly answer or address the user's specific query, which may be in English or Indonesian.`,
                        task: `Select the TOP 5 most relevant highlights that best answer the user's query. The user's query can be in English or Indonesian.`,
                        process: `
1. Analyze the user's query, whether it is in English or Indonesian, to identify their specific need, problem, or area of interest.
2. Evaluate each highlight for direct relevance to the query's meaning. How well does it answer or address what the user is asking?
3. Score each highlight: HIGH (directly answers query), MEDIUM (related/helpful), LOW (tangentially related).
4. Select only HIGH and strong MEDIUM scoring highlights.
5. Rank the selected highlights by relevance score (best matches first).
6. It's acceptable to select multiple highlights from the same book if they're all highly relevant.
7. Never select duplicate/identical highlights.
8. A maximum of 5 highlights is allowed, but fewer is acceptable if only a few are truly relevant.`,
                        outputFormat: `
- Your response MUST be a valid JSON object.
- The JSON object must have a single key: "recommendations".
- The value must be an array of objects, each with an "id" field.
- Each "id" must match exactly one of the highlight IDs provided.
- Order by relevance (best match first).
- Example: {"recommendations": [{"id": "highlight_3"}, {"id": "highlight_7"}, {"id": "highlight_1"}]}
- Do NOT include any other text, explanations, or markdown formatting.`,
                        content: `Available highlights:\n${highlightData}\n\nUser query: "${userPrompt}"\n\nBest matching highlights (ranked by relevance):`
                    }
                };
                const selectedPrompt = prompts[taskType];
                if (!selectedPrompt) throw new Error(`Unknown task type: ${taskType}`);
                
                let promptString = `# ROLE\n${selectedPrompt.role}`;
                if (selectedPrompt.context) promptString += `\n\n# CONTEXT\n${selectedPrompt.context}`;
                if (selectedPrompt.task) promptString += `\n\n# TASK\n${selectedPrompt.task}`;
                if (selectedPrompt.process) promptString += `\n\n# PROCESS\n${selectedPrompt.process}`;
                if (selectedPrompt.outputFormat) promptString += `\n\n# OUTPUT FORMAT\n${selectedPrompt.outputFormat}`;
                if (selectedPrompt.content) promptString += `\n\n${selectedPrompt.content}`;
                
                return promptString;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log('Initializing Book Recommendation System...');
            new BookRecommendationSystem();

            // --- New code to hide caret after animation ---
            const typingElement = document.querySelector('.typing-animation');

            typingElement.addEventListener('animationend', (event) => {
                // Check if the animation that ended is the 'typing' animation
                if (event.animationName === 'typing') {
                    // Hide the caret by making its border transparent
                    typingElement.style.borderRightColor = 'transparent';
                }
            });
            // --- End of new code ---
        });
    </script>
</body>
</html>